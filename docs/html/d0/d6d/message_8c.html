<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Thread Synch AOSV 2020: src/message.c File Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Thread Synch AOSV 2020
   </div>
   <div id="projectbrief">LKM for exchange messages between threads</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">message.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Handles all procedures releated to messages releated to a group device.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;message.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for message.c:</div>
<div class="dyncontent">
<div class="center"><img src="../../d4/da8/message_8c__incl.png" border="0" usemap="#src_2message_8c" alt=""/></div>
<map name="src_2message_8c" id="src_2message_8c">
<area shape="rect" title="Handles all procedures releated to messages releated to a group device." alt="" coords="681,5,796,32"/>
<area shape="rect" href="../../d2/d0d/message_8h_source.html" title=" " alt="" coords="692,80,785,107"/>
<area shape="rect" title=" " alt="" coords="5,155,96,181"/>
<area shape="rect" title=" " alt="" coords="121,155,239,181"/>
<area shape="rect" title=" " alt="" coords="263,155,374,181"/>
<area shape="rect" title=" " alt="" coords="398,155,495,181"/>
<area shape="rect" title=" " alt="" coords="520,155,643,181"/>
<area shape="rect" title=" " alt="" coords="667,155,810,181"/>
<area shape="rect" title=" " alt="" coords="835,155,952,181"/>
<area shape="rect" title=" " alt="" coords="976,155,1088,181"/>
<area shape="rect" title=" " alt="" coords="1111,155,1235,181"/>
<area shape="rect" title=" " alt="" coords="1260,155,1375,181"/>
<area shape="rect" href="../../d9/d49/types_8h_source.html" title=" " alt="" coords="1399,155,1470,181"/>
<area shape="rect" title=" " alt="" coords="905,229,1012,256"/>
<area shape="rect" title=" " alt="" coords="1036,229,1127,256"/>
<area shape="rect" title=" " alt="" coords="1151,229,1265,256"/>
<area shape="rect" title=" " alt="" coords="1290,229,1433,256"/>
<area shape="rect" title=" " alt="" coords="1457,229,1557,256"/>
<area shape="rect" title=" " alt="" coords="1581,229,1685,256"/>
<area shape="rect" title=" " alt="" coords="1709,229,1808,256"/>
<area shape="rect" title=" " alt="" coords="1833,229,1941,256"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abcd6e2e843100cdfc613241a02a4910c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/message_8c.html#abcd6e2e843100cdfc613241a02a4910c">isValidSizeLimits</a> (msg_t *msg, msg_manager_t *manager)</td></tr>
<tr class="memdesc:abcd6e2e843100cdfc613241a02a4910c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the delivery of msg will exceed max sizes.  <a href="../../d0/d6d/message_8c.html#abcd6e2e843100cdfc613241a02a4910c">More...</a><br /></td></tr>
<tr class="separator:abcd6e2e843100cdfc613241a02a4910c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c35593582090f7294b459faf6a51e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/message_8c.html#a59c35593582090f7294b459faf6a51e1">debugMsg</a> (msg_t msg)</td></tr>
<tr class="memdesc:a59c35593582090f7294b459faf6a51e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a msg_t structure.  <a href="../../d0/d6d/message_8c.html#a59c35593582090f7294b459faf6a51e1">More...</a><br /></td></tr>
<tr class="separator:a59c35593582090f7294b459faf6a51e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe680d2cb4664ed30117bea22d4733a0"><td class="memItemLeft" align="right" valign="top"><a id="abe680d2cb4664ed30117bea22d4733a0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isDelaySet</b> (const msg_manager_t *manager)</td></tr>
<tr class="separator:abe680d2cb4664ed30117bea22d4733a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ccede09c258649eb302c9eae019bfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/message_8c.html#a39ccede09c258649eb302c9eae019bfd">delayedMessageCallback</a> (struct timer_list *timer)</td></tr>
<tr class="memdesc:a39ccede09c258649eb302c9eae019bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a timer for a delayed message expires.  <a href="../../d0/d6d/message_8c.html#a39ccede09c258649eb302c9eae019bfd">More...</a><br /></td></tr>
<tr class="separator:a39ccede09c258649eb302c9eae019bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58ffeb71713f9051b0e065c1aab6318"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/message_8c.html#af58ffeb71713f9051b0e065c1aab6318">queueDelayedMessage</a> (msg_t *message, msg_manager_t *manager)</td></tr>
<tr class="memdesc:af58ffeb71713f9051b0e065c1aab6318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a delayed message into the pending queue.  <a href="../../d0/d6d/message_8c.html#af58ffeb71713f9051b0e065c1aab6318">More...</a><br /></td></tr>
<tr class="separator:af58ffeb71713f9051b0e065c1aab6318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0205d35a68e74d35bab2858e077865ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/message_8c.html#a0205d35a68e74d35bab2858e077865ae">revokeDelayedMessage</a> (msg_manager_t *manager)</td></tr>
<tr class="memdesc:a0205d35a68e74d35bab2858e077865ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all the delayed message from the queue.  <a href="../../d0/d6d/message_8c.html#a0205d35a68e74d35bab2858e077865ae">More...</a><br /></td></tr>
<tr class="separator:a0205d35a68e74d35bab2858e077865ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e27c8961ac14bd4453f9d64bf2ae43"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/message_8c.html#a03e27c8961ac14bd4453f9d64bf2ae43">cancelDelay</a> (msg_manager_t *manager)</td></tr>
<tr class="memdesc:a03e27c8961ac14bd4453f9d64bf2ae43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the delay of messages in the delay queue to zero.  <a href="../../d0/d6d/message_8c.html#a03e27c8961ac14bd4453f9d64bf2ae43">More...</a><br /></td></tr>
<tr class="separator:a03e27c8961ac14bd4453f9d64bf2ae43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52aa3da94abdefc702cc3cfb60a97a88"><td class="memItemLeft" align="right" valign="top"><a id="a52aa3da94abdefc702cc3cfb60a97a88"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/message_8c.html#a52aa3da94abdefc702cc3cfb60a97a88">copy_current_participants</a> (struct list_head *dest, struct list_head *source)</td></tr>
<tr class="memdesc:a52aa3da94abdefc702cc3cfb60a97a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy the list of participants into a new list <br /></td></tr>
<tr class="separator:a52aa3da94abdefc702cc3cfb60a97a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b3209a3f195a419481e99636a099dc"><td class="memItemLeft" align="right" valign="top">u_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/message_8c.html#a88b3209a3f195a419481e99636a099dc">count_recipients_safe</a> (struct <a class="el" href="../../df/d34/structt__message__deliver.html">t_message_deliver</a> *msg_deliver)</td></tr>
<tr class="memdesc:a88b3209a3f195a419481e99636a099dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the current number of recipient in a message deliver.  <a href="../../d0/d6d/message_8c.html#a88b3209a3f195a419481e99636a099dc">More...</a><br /></td></tr>
<tr class="separator:a88b3209a3f195a419481e99636a099dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16e668a594905443a0f204de647b12e"><td class="memItemLeft" align="right" valign="top">u_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/message_8c.html#ad16e668a594905443a0f204de647b12e">count_recipients</a> (struct <a class="el" href="../../df/d34/structt__message__deliver.html">t_message_deliver</a> *msg_deliver)</td></tr>
<tr class="memdesc:ad16e668a594905443a0f204de647b12e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the current number of recipient in a message deliver.  <a href="../../d0/d6d/message_8c.html#ad16e668a594905443a0f204de647b12e">More...</a><br /></td></tr>
<tr class="separator:ad16e668a594905443a0f204de647b12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2934d9937454f772195295ab4f8f8f86"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/message_8c.html#a2934d9937454f772195295ab4f8f8f86">deallocate_recipients</a> (struct <a class="el" href="../../df/d34/structt__message__deliver.html">t_message_deliver</a> *msg_deliver)</td></tr>
<tr class="memdesc:a2934d9937454f772195295ab4f8f8f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate the current recipients in a message deliver structure.  <a href="../../d0/d6d/message_8c.html#a2934d9937454f772195295ab4f8f8f86">More...</a><br /></td></tr>
<tr class="separator:a2934d9937454f772195295ab4f8f8f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0620c5b4b142ad0dce341cc24fb8c9b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/message_8c.html#a0620c5b4b142ad0dce341cc24fb8c9b8">deallocate_recipients_safe</a> (struct <a class="el" href="../../df/d34/structt__message__deliver.html">t_message_deliver</a> *msg_deliver)</td></tr>
<tr class="memdesc:a0620c5b4b142ad0dce341cc24fb8c9b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocate the current recipients in a message deliver structure.  <a href="../../d0/d6d/message_8c.html#a0620c5b4b142ad0dce341cc24fb8c9b8">More...</a><br /></td></tr>
<tr class="separator:a0620c5b4b142ad0dce341cc24fb8c9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac138128d3197b5459a302cb5137c7942"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/message_8c.html#ac138128d3197b5459a302cb5137c7942">wasDelivered</a> (const struct list_head *recipients, const pid_t my_pid)</td></tr>
<tr class="memdesc:ac138128d3197b5459a302cb5137c7942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a given pid is present in the recepit list.  <a href="../../d0/d6d/message_8c.html#ac138128d3197b5459a302cb5137c7942">More...</a><br /></td></tr>
<tr class="separator:ac138128d3197b5459a302cb5137c7942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae8aca78c8dac257e44d3c282d7c6cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/message_8c.html#aeae8aca78c8dac257e44d3c282d7c6cb">setDelivered</a> (struct list_head *recipients, const pid_t my_pid)</td></tr>
<tr class="memdesc:aeae8aca78c8dac257e44d3c282d7c6cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a PID to the delivered list of a message.  <a href="../../d0/d6d/message_8c.html#aeae8aca78c8dac257e44d3c282d7c6cb">More...</a><br /></td></tr>
<tr class="separator:aeae8aca78c8dac257e44d3c282d7c6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9b7ed942a40af45dd9b2fdf83106cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/message_8c.html#a7d9b7ed942a40af45dd9b2fdf83106cd">isDeliveryCompleted</a> (const struct list_head *recipients, const struct list_head *active_member)</td></tr>
<tr class="memdesc:a7d9b7ed942a40af45dd9b2fdf83106cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the set of recipients of a message contains all the active members.  <a href="../../d0/d6d/message_8c.html#a7d9b7ed942a40af45dd9b2fdf83106cd">More...</a><br /></td></tr>
<tr class="separator:a7d9b7ed942a40af45dd9b2fdf83106cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02620253a55902a0dc6e793191a678a8"><td class="memItemLeft" align="right" valign="top">__must_check int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/message_8c.html#a02620253a55902a0dc6e793191a678a8">copy_msg_to_user</a> (const msg_t *kmsg, __user int8_t *ubuffer, const ssize_t _size)</td></tr>
<tr class="memdesc:a02620253a55902a0dc6e793191a678a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy a msg_t structure from kernel-space to user-space  <a href="../../d0/d6d/message_8c.html#a02620253a55902a0dc6e793191a678a8">More...</a><br /></td></tr>
<tr class="separator:a02620253a55902a0dc6e793191a678a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0bbdede7f7c74403859a3e2d367aee"><td class="memItemLeft" align="right" valign="top">__must_check int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/message_8c.html#aaa0bbdede7f7c74403859a3e2d367aee">copy_msg_from_user</a> (msg_t *kmsg, const int8_t *umsg, const ssize_t _size)</td></tr>
<tr class="memdesc:aaa0bbdede7f7c74403859a3e2d367aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy a msg_t structure from user-space to kernel-space  <a href="../../d0/d6d/message_8c.html#aaa0bbdede7f7c74403859a3e2d367aee">More...</a><br /></td></tr>
<tr class="separator:aaa0bbdede7f7c74403859a3e2d367aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc02c47c992c949112e71e5cc705618"><td class="memItemLeft" align="right" valign="top">__must_check msg_manager_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/message_8c.html#a0fc02c47c992c949112e71e5cc705618">createMessageManager</a> (const u_int _max_storage_size, const u_int _max_message_size, garbage_collector_t *garbage_collector)</td></tr>
<tr class="memdesc:a0fc02c47c992c949112e71e5cc705618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize all the members of a 'msg_manager_t' struct.  <a href="../../d0/d6d/message_8c.html#a0fc02c47c992c949112e71e5cc705618">More...</a><br /></td></tr>
<tr class="separator:a0fc02c47c992c949112e71e5cc705618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba93a9118165a7e11a1b0865f78da85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/message_8c.html#a1ba93a9118165a7e11a1b0865f78da85">writeMessage</a> (msg_t *message, msg_manager_t *manager)</td></tr>
<tr class="memdesc:a1ba93a9118165a7e11a1b0865f78da85"><td class="mdescLeft">&#160;</td><td class="mdescRight">write message on a group queue  <a href="../../d0/d6d/message_8c.html#a1ba93a9118165a7e11a1b0865f78da85">More...</a><br /></td></tr>
<tr class="separator:a1ba93a9118165a7e11a1b0865f78da85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0eb4f46db2a45d736b02c2ac731fdba"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/message_8c.html#af0eb4f46db2a45d736b02c2ac731fdba">readMessage</a> (msg_t *dest_buffer, msg_manager_t *manager)</td></tr>
<tr class="memdesc:af0eb4f46db2a45d736b02c2ac731fdba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a message from the corresponding queue.  <a href="../../d0/d6d/message_8c.html#af0eb4f46db2a45d736b02c2ac731fdba">More...</a><br /></td></tr>
<tr class="separator:af0eb4f46db2a45d736b02c2ac731fdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1d8514abde9dfb52f2fb006fd5dbf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6d/message_8c.html#aba1d8514abde9dfb52f2fb006fd5dbf1">queueGarbageCollector</a> (struct work_struct *work)</td></tr>
<tr class="memdesc:aba1d8514abde9dfb52f2fb006fd5dbf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a message from the queue when it was completely delivered.  <a href="../../d0/d6d/message_8c.html#aba1d8514abde9dfb52f2fb006fd5dbf1">More...</a><br /></td></tr>
<tr class="separator:aba1d8514abde9dfb52f2fb006fd5dbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Handles all procedures releated to messages releated to a group device. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a03e27c8961ac14bd4453f9d64bf2ae43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e27c8961ac14bd4453f9d64bf2ae43">&#9670;&nbsp;</a></span>cancelDelay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cancelDelay </td>
          <td>(</td>
          <td class="paramtype">msg_manager_t *&#160;</td>
          <td class="paramname"><em>manager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the delay of messages in the delay queue to zero. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">manager</td><td>The group's message manager</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of messages which delay was cancelled</dd></dl>
<dl class="section note"><dt>Note</dt><dd>At the moment the function locks the delayed queue, set all timers to zero and unlock the queue. This means that while the function loops through the queue, timer's callback will wait since the queue is locked. </dd></dl>

</div>
</div>
<a id="aaa0bbdede7f7c74403859a3e2d367aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0bbdede7f7c74403859a3e2d367aee">&#9670;&nbsp;</a></span>copy_msg_from_user()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__must_check int copy_msg_from_user </td>
          <td>(</td>
          <td class="paramtype">msg_t *&#160;</td>
          <td class="paramname"><em>kmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>umsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ssize_t&#160;</td>
          <td class="paramname"><em>_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copy a msg_t structure from user-space to kernel-space </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">kmsg</td><td>Kernel-space msg_t </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">umsg</td><td>User-space msg_t</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>if the copy fails</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000006">Todo:</a></b></dt><dd>Check thread-safety of the function </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The kmsg structure must be allocated </dd></dl>

</div>
</div>
<a id="a02620253a55902a0dc6e793191a678a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02620253a55902a0dc6e793191a678a8">&#9670;&nbsp;</a></span>copy_msg_to_user()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__must_check int copy_msg_to_user </td>
          <td>(</td>
          <td class="paramtype">const msg_t *&#160;</td>
          <td class="paramname"><em>kmsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">__user int8_t *&#160;</td>
          <td class="paramname"><em>ubuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ssize_t&#160;</td>
          <td class="paramname"><em>_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copy a msg_t structure from kernel-space to user-space </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">kmsg</td><td>Kernel-space msg_t </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">umsg</td><td>User-space buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>if the copy fails</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000005">Todo:</a></b></dt><dd>Check thread-safety of the function </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The umsg structure must be allocated </dd></dl>

</div>
</div>
<a id="ad16e668a594905443a0f204de647b12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16e668a594905443a0f204de647b12e">&#9670;&nbsp;</a></span>count_recipients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u_int count_recipients </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="../../df/d34/structt__message__deliver.html">t_message_deliver</a> *&#160;</td>
          <td class="paramname"><em>msg_deliver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the current number of recipient in a message deliver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg_deliver</td><td>A <a class="el" href="../../df/d34/structt__message__deliver.html" title="Contains a &#39;msg_t&#39; structure and the relative delivery info.">t_message_deliver</a> structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is NOT thread-safe with respect to recipients atomic_long_read should be called only when the recipient lock is held in read mode.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>number of recipients in the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88b3209a3f195a419481e99636a099dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b3209a3f195a419481e99636a099dc">&#9670;&nbsp;</a></span>count_recipients_safe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u_int count_recipients_safe </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="../../df/d34/structt__message__deliver.html">t_message_deliver</a> *&#160;</td>
          <td class="paramname"><em>msg_deliver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the current number of recipient in a message deliver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg_deliver</td><td>A <a class="el" href="../../df/d34/structt__message__deliver.html" title="Contains a &#39;msg_t&#39; structure and the relative delivery info.">t_message_deliver</a> structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe with respect to recipients</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>number of recipients in the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fc02c47c992c949112e71e5cc705618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc02c47c992c949112e71e5cc705618">&#9670;&nbsp;</a></span>createMessageManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__must_check msg_manager_t* createMessageManager </td>
          <td>(</td>
          <td class="paramtype">const u_int&#160;</td>
          <td class="paramname"><em>_max_storage_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const u_int&#160;</td>
          <td class="paramname"><em>_max_message_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">garbage_collector_t *&#160;</td>
          <td class="paramname"><em>garbage_collector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate and initialize all the members of a 'msg_manager_t' struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_max_message_size</td><td>Configurable param </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_max_storage_size</td><td>Configurable param </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">garbageCollectorFunction</td><td>Pointer to the work_struct responsible for garbage collection</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">An</td><td>'msg_manager_t' pointer to an allocated an initialized 'msg_manager_t' struct </td></tr>
    <tr><td class="paramname">A</td><td>NULL pointer in case the 'kmalloc' fails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2934d9937454f772195295ab4f8f8f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2934d9937454f772195295ab4f8f8f86">&#9670;&nbsp;</a></span>deallocate_recipients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int deallocate_recipients </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="../../df/d34/structt__message__deliver.html">t_message_deliver</a> *&#160;</td>
          <td class="paramname"><em>msg_deliver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate the current recipients in a message deliver structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg_deliver</td><td>A <a class="el" href="../../df/d34/structt__message__deliver.html" title="Contains a &#39;msg_t&#39; structure and the relative delivery info.">t_message_deliver</a> structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is NOT thread-safe with respect to recipients and should be called only when the recipient lock is held in read mode.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>number of deallocated recipients in the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0620c5b4b142ad0dce341cc24fb8c9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0620c5b4b142ad0dce341cc24fb8c9b8">&#9670;&nbsp;</a></span>deallocate_recipients_safe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int deallocate_recipients_safe </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="../../df/d34/structt__message__deliver.html">t_message_deliver</a> *&#160;</td>
          <td class="paramname"><em>msg_deliver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deallocate the current recipients in a message deliver structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg_deliver</td><td>A <a class="el" href="../../df/d34/structt__message__deliver.html" title="Contains a &#39;msg_t&#39; structure and the relative delivery info.">t_message_deliver</a> structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe with respect to recipients list</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>number of deallocated recipients in the list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59c35593582090f7294b459faf6a51e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c35593582090f7294b459faf6a51e1">&#9670;&nbsp;</a></span>debugMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void debugMsg </td>
          <td>(</td>
          <td class="paramtype">msg_t&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a msg_t structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>The 'msg_t' to print </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothign </dd></dl>

</div>
</div>
<a id="a39ccede09c258649eb302c9eae019bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ccede09c258649eb302c9eae019bfd">&#9670;&nbsp;</a></span>delayedMessageCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delayedMessageCallback </td>
          <td>(</td>
          <td class="paramtype">struct timer_list *&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a timer for a delayed message expires. </p>
<p>The function simply take the existing '<a class="el" href="../../d6/d20/structt__message__delayed__deliver.html" title="Contains a &#39;msg_t&#39; structure and the timer needed to delay the delivery.">t_message_delayed_deliver</a>' structure, extract the 'msg_t' field and write it into the FIFO queue via the 'writeMessage' function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timer</td><td>The timer that elasped </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing </dd></dl>

</div>
</div>
<a id="a7d9b7ed942a40af45dd9b2fdf83106cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d9b7ed942a40af45dd9b2fdf83106cd">&#9670;&nbsp;</a></span>isDeliveryCompleted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isDeliveryCompleted </td>
          <td>(</td>
          <td class="paramtype">const struct list_head *&#160;</td>
          <td class="paramname"><em>recipients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct list_head *&#160;</td>
          <td class="paramname"><em>active_member</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the set of recipients of a message contains all the active members. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recipients</td><td>The recipients of the message to 'wasDelivered' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">active_member</td><td>The list of active members to compare</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if active members is contained in recipients </td></tr>
    <tr><td class="paramname">false</td><td>if active members is NOT contained in recipients</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function must be called only when there is a reader lock on the active_member recipients structure </dd></dl>

</div>
</div>
<a id="abcd6e2e843100cdfc613241a02a4910c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd6e2e843100cdfc613241a02a4910c">&#9670;&nbsp;</a></span>isValidSizeLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isValidSizeLimits </td>
          <td>(</td>
          <td class="paramtype">msg_t *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">msg_manager_t *&#160;</td>
          <td class="paramname"><em>manager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the delivery of msg will exceed max sizes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>The message to test for </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the size limits are respected </td></tr>
    <tr><td class="paramname">false</td><td>if the size exceed the limits</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread-safe </dd></dl>

</div>
</div>
<a id="af58ffeb71713f9051b0e065c1aab6318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58ffeb71713f9051b0e065c1aab6318">&#9670;&nbsp;</a></span>queueDelayedMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int queueDelayedMessage </td>
          <td>(</td>
          <td class="paramtype">msg_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">msg_manager_t *&#160;</td>
          <td class="paramname"><em>manager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a delayed message into the pending queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>The message to insert into the queue </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">manager</td><td>A pointer to the current msg_manager_t of the group</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">-1</td><td>on error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba1d8514abde9dfb52f2fb006fd5dbf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba1d8514abde9dfb52f2fb006fd5dbf1">&#9670;&nbsp;</a></span>queueGarbageCollector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void queueGarbageCollector </td>
          <td>(</td>
          <td class="paramtype">struct work_struct *&#160;</td>
          <td class="paramname"><em>work</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a message from the queue when it was completely delivered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">work</td><td>The work struct contained inside "msg_manager_t"</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function has three critical section, therefore it could be a bottleneck of the module </dd></dl>

</div>
</div>
<a id="af0eb4f46db2a45d736b02c2ac731fdba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0eb4f46db2a45d736b02c2ac731fdba">&#9670;&nbsp;</a></span>readMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int readMessage </td>
          <td>(</td>
          <td class="paramtype">msg_t *&#160;</td>
          <td class="paramname"><em>dest_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">msg_manager_t *&#160;</td>
          <td class="paramname"><em>manager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a message from the corresponding queue. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">1</td><td>if no message is present </td></tr>
    <tr><td class="paramname">-1</td><td>on critical error </td></tr>
  </table>
  </dd>
</dl>
<p>This should't be necessary since the message's sender is automatically added in the list of recipients and, consequently, the 'wasDelivered' function should skip it. However for unknown reason this does not always happens (especially if the message is delayed)</p>
<dl class="bug"><dt><b><a class="el" href="../../de/da5/bug.html#_bug000001">Bug:</a></b></dt><dd>: when 'revoke delay' functionality is called, messages trigger this if and will not be delivered </dd></dl>

</div>
</div>
<a id="a0205d35a68e74d35bab2858e077865ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0205d35a68e74d35bab2858e077865ae">&#9670;&nbsp;</a></span>revokeDelayedMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int revokeDelayedMessage </td>
          <td>(</td>
          <td class="paramtype">msg_manager_t *&#160;</td>
          <td class="paramname"><em>manager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all the delayed message from the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">manager</td><td>The message manager of the group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is thread safe with respect to the list of delayed message</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of delayed messages which revoked </dd></dl>

</div>
</div>
<a id="aeae8aca78c8dac257e44d3c282d7c6cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae8aca78c8dac257e44d3c282d7c6cb">&#9670;&nbsp;</a></span>setDelivered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setDelivered </td>
          <td>(</td>
          <td class="paramtype">struct list_head *&#160;</td>
          <td class="paramname"><em>recipients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pid_t&#160;</td>
          <td class="paramname"><em>my_pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a PID to the delivered list of a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recipients</td><td>The list_head structure of a '<a class="el" href="../../df/d34/structt__message__deliver.html" title="Contains a &#39;msg_t&#39; structure and the relative delivery info.">t_message_deliver</a>' struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">my_pid</td><td>The pid to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is NOT thread-safe and must be called while holding a lock to the recipient's list.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>nothing </dd></dl>

</div>
</div>
<a id="ac138128d3197b5459a302cb5137c7942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac138128d3197b5459a302cb5137c7942">&#9670;&nbsp;</a></span>wasDelivered()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wasDelivered </td>
          <td>(</td>
          <td class="paramtype">const struct list_head *&#160;</td>
          <td class="paramname"><em>recipients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pid_t&#160;</td>
          <td class="paramname"><em>my_pid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a given pid is present in the recepit list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">recipients</td><td>The list of recipients of the message to check </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">my_pid</td><td>The PID to check</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the provided pid is present in the recipient list </td></tr>
    <tr><td class="paramname">false</td><td>if the pid is not present in the recipient list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is not thread-safe, so it must be called after locking the recipient list </dd>
<dd>
A possible improvement would sort the list and return if the current member's pid is greater than 'my_pid' </dd></dl>

</div>
</div>
<a id="a1ba93a9118165a7e11a1b0865f78da85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba93a9118165a7e11a1b0865f78da85">&#9670;&nbsp;</a></span>writeMessage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int writeMessage </td>
          <td>(</td>
          <td class="paramtype">msg_t *&#160;</td>
          <td class="paramname"><em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">msg_manager_t *&#160;</td>
          <td class="paramname"><em>manager</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write message on a group queue </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">message</td><td>The data pointed must never be deallocatated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">manager</td><td>Pointer to the message manager </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">recipients</td><td>The head of the linked list containing the thread recipients</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">STORAGE_SIZE_ERR</td><td>if the message does not respect the group's size limits </td></tr>
    <tr><td class="paramname">ALLOC_ERR</td><td>if some allocation fails</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Must be protected by a write-spinlock to avoid concurrent modification of The recipient data-structure and manager's message queue </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
